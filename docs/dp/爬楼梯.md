# 70爬楼梯

## 介绍

```
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/climbing-stairs
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 思维

- Clarification(细节，边界，可能出现的极端情况)
- Possible Solution(所有可能的解法)
   - 空间和时间复杂度
   - 最优解是？
- Coding 写代码
- Testing 测试用例

## 解法

### Clarification
    爬楼梯可以一次爬两层和一层

    那么状态的定义就是 爬到当前楼梯的可能次数dp[i] = dp[i - 1] + dp[i - 2] 两种
    

### dp解法 

    见123 example 1

    一共定义3个维度的状态
    
    第一个维度 每天的利润
    第二个维度 交易k次
    第三个维度 收上有还是没有

    对于每个 i > 1, k > 1 
    都有 dp[i][k][0] = Math.max(dp[i - 1][k][0], dp[i - 1][k - 1][1] + prices[i])
    dp[i][k][1] = Math.max(dp[i - 1][k][1], dp[i - 1][k][0] - price[i])
    对于每个 i > 1, k = 0
    都有 dp[i][0][0] = dp[i - 1][0][0]
    dp[i][0][1] = Math.max(dp[i- 1][0][1], dp[i - 1][0][0] - price[i])

    注意初始值 dp[0][0][0] = 0
              dp[0][0][1] = -price[0]
              其他要设置一个Nunber 最小值

    最优解 就是   dp[0][k][0], ... ,dp[1][k][0]的最大值
    
    可能不做满2笔交易，因为股票可能一直跌
    

### 状态机解法

   见123 example 2
   
   在2次交易的情况比较优雅
   
   定义4个状态

   买一次的最大利润 之前的买一次(起始 -max) or -当前价格 的最大值 
   卖一次的最大利润 之前卖一次 or 之前买了一次这次卖的最大值
   买两次的最大利润 之前买两次(起始 -max) or  之前卖一次的解 - 当前价格
   卖两次的最大利润 之前卖两次 or 之前买两次的值 + 当前价格 的最大值
   



